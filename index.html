<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked List and Data Structure C Code Repository</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', 'monospace'],
                    },
                    colors: {
                        'neon-cyan': '#00FFFF',
                        'bg-dark': '#0f172a',
                        'code-bg-dark': '#1e293b',
                        'text-light': '#f8fafc',
                    }
                }
            }
        }
    </script>
    <style>
        .card {
            background-color: var(--code-bg-dark);
            border-radius: 0.75rem;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 255, 255, 0.4);
        }
        .code-container {
            border: 1px solid var(--neon-cyan);
            background-color: #000000;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.4);
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
            font-size: 0.95rem; 
            color: var(--neon-cyan);
        }
        .neon-button {
            background-color: #000000;
            color: var(--neon-cyan);
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6), inset 0 0 5px rgba(0, 255, 255, 0.4);
            transition: all 0.3s ease;
        }
        .neon-button:hover {
            background-color: var(--neon-cyan);
            color: var(--bg-dark);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }
        .list-card-glow:hover {
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            border-color: var(--neon-cyan);
        }
        #code-detail {
            max-width: 800px;
            margin: 0 auto;
        }
    </style>
</head>
<body class="bg-bg-dark min-h-screen text-text-light">

    <div id="app" class="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <header class="text-center mb-12 p-6 card border-b-4 border-neon-cyan relative">
            <h1 class="text-4xl font-extrabold text-text-light sm:text-5xl">
                Data Structures C Code Repository
            </h1>
            <p class="mt-4 text-xl text-neon-cyan mb-4">
                Linked Lists, Stacks, and Queues - Accessible Anywhere
            </p>
            <!-- New Backup Link -->
            <a href="https://jyotirmoyyyyyy.github.io/u/" target="_blank" class="neon-button inline-flex items-center px-4 py-1 text-sm font-medium rounded-lg no-underline hover:text-bg-dark transition-colors duration-200">
                Backup Repository
            </a>
            <!-- End New Backup Link -->
        </header>

        <!-- Main Code List View -->
        <div id="code-list-view" class="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
        </div>

        <!-- Code Detail View -->
        <div id="code-detail-view" class="hidden">
            <button id="back-button" class="flex items-center text-neon-cyan hover:text-text-light font-semibold mb-6 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 mr-1"><path d="m15 18-6-6 6-6"/></svg>
                Back to All Codes
            </button>
            <div id="code-detail" class="card p-6">
                <h2 id="detail-title" class="text-3xl font-bold text-text-light mb-2"></h2>
                <p id="detail-filename" class="text-sm text-gray-400 mb-6"></p>
                <div id="detail-code-container" class="code-container">
                    <pre id="detail-code" class="text-base text-neon-cyan overflow-x-auto code-block font-mono"></pre>
                </div>
                <button id="detail-copy-button" class="neon-button mt-6 px-6 py-2 text-base font-medium rounded-lg">
                    Copy Code
                </button>
            </div>
        </div>

        <footer class="mt-16 text-center text-gray-500 text-sm">
            <p>&copy; 2024 C Code Repository. All codes extracted from provided files.</p>
        </footer>
    </div>

    <script>
        // Data containing all the code snippets with their respective titles
        const codes = [
            {
                title: "PROGRAM OF CIRCULAR DOUBLE LINKED LIST",
                filename: "pca.pdf (Program 1)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\ntypedef struct link\n\n{\n\nstruct link *prev;\n\nint info;\n\nstruct link *next;\n\n}node;\n\nvoid main()\n\n{\n\nnode *head1,*head2;\n\nvoid creat(node *, node *);\n\nvoid show(node *, node *);\n\nhead1=(node *)malloc(sizeof(node));\n\nhead2=head1;\n\nclrscr();\n\nprintf("\\nCreate a doubly circular linked list");\n\ncreat(head1, head2);\n\nprintf("\\nDisplay ");\n\nshow(head1,head2);\n\ngetch();\n\n}\n\nvoid creat(node *temp1, node *temp2)\n\n{\n\nnode *p,*q;\n\nchar ans;\n\nwhile(1)\n\n{\n\np=temp1;\n\nprintf("\\nEnter the info:: ");\n\nscanf("%d", &temp1->info);\n\nprintf("\\nWant another?");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nbreak;\n\nelse\n\n{\n\ntemp1->next=(node *)malloc(sizeof(node));\n\ntemp1=temp1->next;\n\ntemp1->prev=p;\n\n}\n\n}\n\ntemp1->next=temp2;\n\ntemp2->prev=temp1;\n\n}\n\nvoid show(node *temp1, node *temp2)\n\n{\n\nnode *p;\n\nwhile(temp1->next!=temp2)\n\n{\n\nprintf("%4d",temp1->info);\n\ntemp1=temp1->next;\n\n}\n\nif(temp1->next==temp2)\n\nprintf("%4d",temp1->info);\n\np=temp1;\n\nwhile(temp1->prev!=p)\n\n{\n\nprintf("%4d",temp1->info);\n\ntemp1=temp1->prev;\n\n}\n\nif(temp1->prev==p)\n\nprintf("%4d",temp1->info);\n\n}`
            },
            {
                title: "PROGRAM OF CIRCULAR LINKED LIST INSERTION",
                filename: "pca.pdf (Program 2)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\nstruct link\n\n{\n\nint info;\n\nstruct link *next;\n\n};\n\ntypedef struct link node;\n\nvoid main()\n\n{\n\nnode *head1,*head2;\n\nclrscr();\n\nvoid create(node *, node *);\n\nvoid show(node *, node *);\n\nnode *insert_fst(node *);\n\nnode *insert_lst(node *);\n\nnode *del_fst(node *);\n\nnode *del_lst(node *);\n\nhead1=(node *)malloc(sizeof(node));\n\nhead2=head1;\n\nprintf("\\n\\tCreate the linked list:\\n");\n\ncreate(head1,head2);\n\nprintf("\\n\\tDisplay the linked list:\\n");\n\nshow(head1,head2);\n\nprintf("\\n\\n\\tInsertion at 1st position.\\n");\n\nhead1=insert_fst(head1);\n\nshow(head1,head1);\n\nprintf("\\n\\n\\tInsertion at last position.\\n");\n\nhead1=insert_lst(head1);\n\nshow(head1,head1);\n\ngetch();\n\nprintf("\\n\\n\\tDeletion at 1st position.\\n");\n\nhead1=del_fst(head1);\n\nshow(head1, head1);\n\ngetch();\n\nprintf("\\n\\n\\tDeletion at last position.\\n");\n\nhead1=del_lst(head1);\n\nshow(head1, head1);\n\ngetch();\n\n}\n\nvoid create(node *temp1, node *temp2)\n\n{\n\nchar ans;\n\nprintf("\\nEnter the info:- ");\n\nscanf("%d",&temp1->info);\n\ntemp1->next=temp2;\n\nprintf("\\nWant Another? ");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp1->next=(node *)malloc(sizeof(node));\n\ncreate(temp1->next, temp2);\n\n}\n\n}\n\nvoid show(node *temp1, node *temp2)\n\n{\n\nif(temp1->next==temp2)\n\nprintf("%d",temp1->info);\n\nelse\n\n{\n\nprintf("%d->",temp1->info);\n\nshow(temp1->next, temp2);\n\n}\n\n}\n\nnode *insert_fst(node * temp)\n\n{\n\nnode * list,*first;\n\nfirst=temp;\n\nlist=(node *)malloc(sizeof(node));\n\nprintf("\\nEnter the element:- ");\n\nscanf("%d",&list->info);\n\nlist->next=temp;\n\nwhile(temp->next!=first)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next==first)\n\n{\n\ntemp->next=list;\n\n}\n\ntemp=list;\n\nreturn(temp);\n\n}\n\nnode *insert_lst(node *temp)\n\n{\n\nnode *last,*first;\n\nfirst=temp;\n\nwhile(temp->next!=first)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next==first)\n\n{\n\nlast=(node *)malloc(sizeof(node));\n\nprintf("\\nEnter the element:- ");\n\nscanf("%d", &last->info);\n\ntemp->next=last;\n\nlast->next=first;\n\n}\n\nreturn(first);\n\n}\n\nnode *del_fst(node * temp)\n\n{\n\nnode * list,*first;\n\nfirst=temp;\n\ntemp=temp->next;\n\nlist=temp;\n\nwhile(temp->next!=first)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next==first)\n\n{\n\ntemp->next=list;\n\n}\n\nfree(first);\n\nreturn(list);\n\n}\n\nnode *del_lst(node *temp)\n\n{\n\nnode *last,*first;\n\nfirst=temp;\n\nwhile(temp->next->next!=first)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next->next==first)\n\n{\n\nlast=temp->next;\n\nfree(last);\n\ntemp->next=first;\n\n}\n\nreturn(first);\n\n}`
            },
            {
                title: "PROGRAM OF DOUBLE LINKED LIST INSERTION & DELETION (ANY POSITION)",
                filename: "pca.pdf (Program 3)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\n#define NULL 0\n\nstruct link\n\n{\n\nstruct link *prev;\n\nint info;\n\nstruct link *next;\n\n};\n\ntypedef struct link node;\n\nvoid create(node *);\n\nvoid show(node *);\n\nnode* insert(node*);\n\nnode* del(node*);\n\nnode* find (node *,int);\n\nvoid main()\n\n{\n\nnode *head;\n\nclrscr();\n\nhead=(node *)malloc(sizeof(node));\n\nprintf("\\nCreate the linked list:\\n");\n\ncreate(head);\n\nprintf("\\nDisplay the linked list:\\n");\n\nshow(head);\n\ngetch();\n\nclrscr();\n\nprintf("\\nInsert number at any position in the given linked list:\\n");\n\nshow(head);\n\nhead=insert(head);\n\nshow(head);\n\ngetch();\n\nclrscr();\n\nprintf("\\nDelete number from any position in the given linked list:\\n");\n\nshow(head);\n\nhead=del(head);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nnode *p;\n\ntemp->prev=NULL;\n\nprintf("\\n\\tEnter the info:- ");\n\nscanf("%d",&temp->info);\n\nwhile(1)\n\n{\n\nprintf("\\n\\tWant Another? ");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nbreak;\n\nelse\n\n{\n\np=temp;\n\ntemp->next=(node *)malloc(sizeof(node));\n\ntemp=temp->next;\n\ntemp->prev=p;\n\nprintf("\\n\\tEnter the info:- ");\n\nscanf("%d",&temp->info);\n\n}\n\n}\n\ntemp->next=NULL;\n\n}\n\nvoid show(node *temp)\n\n{\n\nprintf("\\n\\t");\n\nwhile(temp->next!=NULL)\n\n{\n\nprintf("%d<->",temp->info);\n\ntemp=temp->next;\n\n}\n\nif(temp->next==NULL)\n\n{\n\n}\n\nprintf("%d",temp->info);\n\nprintf("\\n\\n\\t");\n\nwhile(temp->prev!=NULL)\n\n{\n\n}\n\nprintf("%d<->",temp->info);\n\ntemp=temp->prev;\n\nif(temp->prev==NULL)\n\n{\n\n}\n\nprintf("%d",temp->info);\n\n}\n\nnode *insert(node *temp)\n\n{\n\nint key;\n\nnode *mid,*n1,*first;\n\nfirst=temp;\n\nmid=(node *)malloc(sizeof(node));\n\nprintf("\\n\\nInsert Before which number?");\n\nprintf("\\nNote:: (Give -9999 if INSERTING at the END of list!)");\n\nscanf("%d", &key);\n\nprintf("\\nNumber to be Inserted:"); scanf("%d", &mid->info);\n\nif(temp->info==key)\n\n{\n\nmid->prev=NULL;\n\nmid->next=temp;\n\ntemp->prev=mid;\n\ntemp=mid;\n\n}\n\nelse\n\n{\n\nn1=find(temp,key);\n\nif(n1==NULL)\n\n{\n\nprintf("\\n\\tKey not FOUND, Inserting at the END!\\n");\n\nwhile(temp->next!=NULL)\n\ntemp=temp->next;\n\nmid->prev=temp;\n\nmid->next=NULL;\n\ntemp->next=mid;\n\ntemp=first;\n\n}\n\nelse\n\n{\n\nmid->prev=n1;\n\nmid->next=n1->next;\n\nn1->next=mid;\n\nmid->next->prev=mid;\n\n}\n\n}\n\nreturn(temp);\n\n}\n\nnode *find(node *temp, int key)\n\n{\n\nif(temp->next->info==key)\n\nreturn(temp);\n\nelse if(temp->next->next==NULL)\n\nreturn(NULL);\n\nelse\n\nreturn(find(temp->next, key));\n\n}\n\nnode *del(node *temp)\n\n{\n\nint key;\n\nnode *first,*p,*q;\n\nfirst=temp;\n\nprintf("\\n\\nDelete which number? ");\n\nscanf("%d", &key);\n\nwhile(temp->next!=NULL)\n\n{\n\nif(temp->info==key)\n\n{\n\nif(temp->prev!=NULL)\n\n{\n\np=temp->prev;\n\nq=temp->next;\n\nfree(temp);\n\np->next=q;\n\nq->prev=p;\n\n}\n\nelse\n\n{\n\n}\n\ntemp=temp->next;\n\ntemp->prev=NULL;\n\nfirst=temp;\n\ntemp=temp->next;\n\n}\n\n}\n\nif((temp->next==NULL)&&(temp->info==key))\n\n{\n\ntemp=temp->prev;\n\ntemp->next=NULL;\n\n}\n\n\ntemp=first;\n\nreturn(temp);\n\n}`
            },
            {
                title: "PROGRAM OF DOUBLE LINKED LIST",
                filename: "pca.pdf (Program 4)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\n#define NULL 0\n\nstruct link\n\n{\n\nstruct link *prev;\n\nint info;\n\nstruct link *next;\n\n};\n\ntypedef struct link node;\n\nvoid main()\n\n{\n\nnode *head;\n\nclrscr();\n\nvoid create(node *);\n\nvoid show(node *);\n\nnode *insert_fst(node *);\n\nnode *insert_lst(node *);\n\nnode *del_fst(node *);\n\nnode *del_lst(node *);\n\nhead=(node *)malloc(sizeof(node));\n\nprintf("\\n\\tCreate the linked list:\\n");\n\ncreate(head);\n\nprintf("\\n\\tDisplay the linked list:\\n");\n\nshow(head);\n\nprintf("\\n\\n\\tInsertion at 1st position.\\n");\n\nhead=insert_fst(head);\n\nshow(head);\n\nprintf("\\n\\n\\tInsertion at last position.\\n");\n\nhead=insert_lst(head);\n\nshow(head);\n\ngetch();\n\nprintf("\\n\\n\\tDeletion at 1st position.\\n");\n\nhead=del_fst(head);\n\nshow(head);\n\ngetch();\n\nprintf("\\n\\n\\tDeletion at last position.\\n");\n\nhead=del_lst(head);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nnode *p;\n\ntemp->prev=NULL;\n\nprintf("\\nEnter the info:- ");\n\nscanf("%d",&temp->info);\n\nwhile(1)\n\n{\n\nprintf("\\nWant Another? ");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nbreak;\n\nelse\n\n{\n\np=temp;\n\ntemp->next=(node *)malloc(sizeof(node));\n\ntemp=temp->next;\n\ntemp->prev=p;\n\nprintf("\\nEnter the info:- ");\n\nscanf("%d", &temp->info);\n\n}\n\n}\n\ntemp->next=NULL;\n\n}\n\nvoid show(node *temp)\n\n{\n\nwhile(temp->next!=NULL)\n\n{\n\nprintf("%d<->",temp->info);\n\ntemp=temp->next;\n\n}\n\nif(temp->next==NULL)\n\n{\n\nprintf("%d",temp->info);\n\n}\n\nprintf("\\n");\n\nwhile(temp->prev!=NULL)\n\n{\n\nprintf("%d<->",temp->info);\n\ntemp=temp->prev;\n\n}\n\nif(temp->prev==NULL)\n\n{\n\nprintf("%d",temp->info);\n\n}\n\n}\n\nnode *insert_fst(node * temp)\n\n{\n\nnode * list;\n\nlist=(node *)malloc(sizeof(node));\n\nlist->prev=NULL;\n\nprintf("\\nEnter the element:- ");\n\nscanf("%d",&list->info);\n\nlist->next=temp;\n\ntemp->prev=list;\n\ntemp=list;\n\nreturn(temp);\n\n}\n\nnode *insert_lst(node *temp)\n\n{\n\nnode *last,*first;\n\nfirst=temp;\n\nwhile(temp->next!=NULL)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next==NULL)\n\n{\n\nlast=(node *)malloc(sizeof(node));\n\nprintf("\\nEnter the element:- ");\n\nscanf("%d", &last->info);\n\ntemp->next=last;\n\nlast->prev=temp;\n\nlast->next=NULL;\n\n}\n\nreturn(first);\n\n}\n\nnode *del_fst(node * temp)\n\n{\n\nnode * list;\n\nif(temp==NULL)\n\nprintf("\\n\\tUNDERFLOW.\\n");\n\nif(temp!=NULL)\n\n{\n\nlist=temp->next;\n\nlist->prev=NULL;\n\nfree(temp);\n\ntemp=list;\n\n}\n\nreturn(temp);\n\n}\n\nnode *del_lst(node *temp)\n\n{\n\nnode *last,*first;\n\nfirst=temp;\n\nwhile(temp->next->next!=NULL)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next->next==NULL)\n\n{\n\nlast=temp->next;\n\nfree(last);\n\ntemp->next=NULL;\n\n}\n\nreturn(first);\n\n}`
            },
            {
                title: "PROGRAM OF LINKED QUEUE",
                filename: "pca.pdf (Program 5)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\n#define NULL 0\n\ntypedef struct link\n\n{\n\nchar info;\n\nstruct link *next;\n\n}node;\n\nnode *insert(node *,char);\n\nnode *remove(node *);\n\nvoid display(node *);\n\nvoid main()\n\n{\n\nnode *first=NULL;\n\nchar item;\n\nint ch;\n\nclrscr();\n\nprintf("\\n\\t1) INSERT.\\n\\t2) REMOVE.\\n\\t3) EXIT.\\n\\n");\n\nwhile(1)\n\n{\n\nprintf("\\nEnter youir choice:- ");\n\nscanf("%d",&ch);\n\nswitch(ch)\n\n{\n\ncase 1:\n\nprintf("\\nEnter the item which you want to insert:- ");\n\nfflush(stdin);\n\nitem=getchar();\n\nfirst=insert(first, item);\n\ndisplay(first);\n\nbreak;\n\ncase 2:\n\nfirst=remove(first);\n\ndisplay(first);\n\nbreak;\n\ncase 3:\n\nexit(0);\n\n}\n\n}\n\ngetch();\n\n}\n\nnode *insert(node *temp, char item)\n\n{\n\nnode *mid,*first;\n\nfirst=temp;\n\nmid=(node *)malloc(sizeof(node));\n\nmid->info=item;\n\nif(first==NULL)\n\n{\n\ntemp=mid;\n\n}\n\nmid->next=NULL;\n\nelse\n\n{\n\nwhile(first->next!=NULL)\n\n{\n\nfirst=first->next;\n\n}\n\n}\n\nfirst->next=mid;\n\nmid->next=NULL;\n\nreturn(temp);\n\n}\n\nnode *remove(node *temp)\n\n{\n\nnode *first;\n\nfirst=temp;\n\nif(first==NULL)\n\n{\n\n}\n\nprintf("\\n\\tUNDREFLOW.\\n");\n\nelse\n\n{\n\nprintf("\\n\\n\\t%c is deleted.\\n",first->info);\n\nfirst=first->next;\n\nfree(temp);\n\ntemp=first;\n\n}\n\nreturn(temp);\n\n}\n\nvoid display(node *temp)\n\n{\n\nprintf("\\n");\n\nwhile(temp!=NULL)\n\n{\n\nprintf("%4c",temp->info);\n\ntemp=temp->next;\n\n}\n\n}`
            },
            {
                title: "IMPLEMENTING STACK OPERATIONS USING LINKED LIST",
                filename: "pca.pdf (Program 6)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\n#define NULL 0\n\ntypedef struct list\n\n{\n\nint data;\n\nstruct list *next;\n\n}node;\n\nvoid main()\n\n{\n\nnode *push(node *);\n\nnode *pop(node *);\n\nvoid display(node *);\n\nnode *stack;\n\nint choice;\n\nchar ch;\n\nstack=NULL;\n\nclrscr();\n\nwhile(1)\n\n{\n\nprintf("\\n\\t1->PUSH");\n\nprintf("\\n\\t2->POP");\n\nprintf("\\n\\t3->DISPLAY");\n\nprintf("\\n\\t4->EXIT");\n\nprintf("\\nEnter your choice");\n\nscanf("%d", &choice);\n\nswitch(choice)\n\n{\n\ncase 1:\n\nstack=push(stack);\n\nbreak;\n\ncase 2:\n\nstack=pop(stack);\n\nbreak;\n\ncase 3:\n\ndisplay(stack);\n\nbreak;\n\ncase 4:\n\nexit(0);\n\ndefault:\n\nprintf("\\nYour choice is invalid");\n\n}\n\n}\n\n}\n\ngetch();\n\nnode *push(node *s)\n\n{\n\nnode *temp;\n\ntemp=(node *)malloc(sizeof(node));\n\nprintf("\\n Enter your data");\n\nscanf("%d",&temp->data);\n\ntemp->next =s;\n\ns=temp;\n\nreturn(s);\n\n}\n\nnode *pop(node *s)\n\n{\n\nnode *temp;\n\nint no;\n\nif(s==NULL)\n\nprintf("\\nStack is empty");\n\nelse\n\n{\n\n}\n\ntemp=s;\n\nprintf("\\n%d if deleted",s->data);\n\ns=temp->next;\n\nreturn(s);\n\n}\n\nvoid display(node *s)\n\n{\n\nwhile(s !=NULL)\n\n{\n\nprintf("\\nstack->data=%d",s->data);\n\ns=s->next;\n\n}\n\nreturn;\n\n}`
            },
            {
                title: "Linked Search and Sort",
                filename: "pca.pdf (Program 7)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\ntypedef struct link\n\n{\n\nint info;\n\nstruct link *next;\n\n}node;\n\nvoid main()\n\n{\n\nnode *head;\n\nvoid create(node *);\n\nvoid show(node *);\n\nvoid search(node *);\n\nvoid sort(node *);\n\nclrscr();\n\nhead=(node *)malloc(sizeof(node));\n\nprintf("\\nCreate");\n\ncreate(head);\n\nprintf("\\nShow");\n\nshow(head);\n\nsearch(head);\n\nprintf("\\nThe sorted list is:\\n");\n\nsort(head);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nprintf("\\nEnter info:");\n\nscanf("%d", &temp->info);\n\ntemp->next=NULL;\n\nprintf("\\nWant another");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreate(temp->next);\n\n}\n\n}\n\nvoid show(node *temp)\n\n{\n\nif(temp->next==NULL)\n\nprintf("%4d",temp->info);\n\nelse\n\n{\n\nprintf("%4d",temp->info);\n\nshow(temp->next);\n\n}\n\n}\n\nvoid search(node * temp)\n\n{\n\nint key,flag=0;\n\nprintf("\\nEnter search item:");\n\nscanf("%d", &key);\n\nwhile(temp!=NULL)\n\n{\n\nif(temp->info==key)\n\n{\n\nflag=1;\n\nbreak;\n\n}\n\ntemp=temp->next;\n\n}\n\nif(flag==1)\n\nprintf("\\nItem Found");\n\nelse\n\nprintf("\\nltem not found.");\n\n}\n\nvoid sort(node * temp)\n\n{\n\nnode *p,*q;\n\nint key;\n\np=temp;\n\nwhile(p!=NULL)\n\n{\n\nq=p->next;\n\nwhile(q!=NULL)\n\n{\n\nif(p->info>q->info)\n\n{\n\nkey=p->info;\n\np->info=q->info;\n\nq->info=key;\n\n}\n\nq=q->next;\n\n}\n\n}\n\np=p->next;\n\n}`
            },
            {
                title: "PROGRAM OF LINEAR LINKED LIST DELETION",
                filename: "pca.pdf (Program 8)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\n#define NULL 0\n\nstruct link\n\n{\n\nint info;\n\nstruct link *next;\n\n};\n\ntypedef struct link node;\n\nvoid main()\n\n{\n\nnode *head;\n\nclrscr();\n\nvoid create(node *);\n\nvoid show(node *);\n\nnode *del_fst(node *);\n\nnode *del_lst(node *);\n\nhead=(node *)malloc(sizeof(node));\n\nprintf("\\n\\tCreate the linked list:\\n");\n\ncreate(head);\n\nprintf("\\n\\tDisplay the linked list:\\n");\n\nshow(head);\n\nprintf("\\n\\n\\tDeletion from 1st position.\\n");\n\nhead=del_fst(head);\n\nshow(head);\n\nprintf("\\n\\n\\tDeletion from last position.\\n");\n\nhead=del_lst(head);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nprintf("\\nEnter the info:- ");\n\nscanf("%d",&temp->info);\n\ntemp->next=NULL;\n\nprintf("\\nWant Another? ");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreate(temp->next);\n\n}\n\n}\n\nvoid show(node *temp)\n\n{\n\nif(temp->next==NULL)\n\nprintf("%d",temp->info);\n\nelse\n\n{\n\nprintf("%d->",temp->info);\n\nshow(temp->next);\n\n}\n\n}\n\nnode *del_fst(node * temp)\n\n{\n\nnode * list;\n\nif(temp==NULL)\n\nprintf("\\n\\tUNDERFLOW.\\n");\n\nif(temp!=NULL)\n\n{\n\nlist=temp->next;\n\nfree(temp);\n\ntemp=list;\n\n}\n\nreturn(temp);\n\n}\n\nnode *del_lst(node *temp)\n\n{\n\nnode *last,*first;\n\nfirst=temp;\n\nwhile(temp->next->next!=NULL)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next->next==NULL)\n\n{\n\nlast=temp->next;\n\nfree(last);\n\ntemp->next=NULL;\n\n}\n\nreturn(first);\n\n}`
            },
            {
                title: "PROGRAM OF LINEAR LINKED LIST",
                filename: "pca.pdf (Program 9)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\n#define NULL 0\n\nstruct link\n\n{\n\nint info;\n\nstruct link *next;\n\n};\n\ntypedef struct link node;\n\nvoid main()\n\n{\n\nnode *head;\n\nclrscr();\n\nvoid create(node *);\n\nvoid show(node *);\n\nnode *insert_fst(node *);\n\nnode *insert_lst(node *);\n\nhead=(node *)malloc(sizeof(node));\n\nprintf("\\n\\tCreate the linked list:\\n");\n\ncreate(head);\n\nprintf("\\n\\tDisplay the linked list:\\n");\n\nshow(head);\n\nprintf("\\n\\n\\tInsertion at 1st position.\\n");\n\nhead=insert_fst(head);\n\nshow(head);\n\nprintf("\\n\\n\\tInsertion at last position.\\n");\n\nhead=insert_lst(head);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nprintf("\\nEnter the info:- ");\n\nscanf("%d",&temp->info);\n\ntemp->next=NULL;\n\nprintf("\\nWant Another? ");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreate(temp->next);\n\n}\n\n}\n\nvoid show(node *temp)\n\n{\n\nif(temp->next==NULL)\n\nprintf("%d",temp->info);\n\nelse\n\n{\n\nprintf("%d->",temp->info);\n\nshow(temp->next);\n\n}\n\n}\n\nnode *insert_fst(node * temp)\n\n{\n\nnode * list;\n\nlist=(node *)malloc(sizeof(node));\n\nprintf("\\nEnter the element:- ");\n\nscanf("%d",&list->info);\n\nlist->next=temp;\n\ntemp=list;\n\nreturn(temp);\n\n}\n\nnode *insert_lst(node *temp)\n\n{\n\nnode *last,*first;\n\nfirst=temp;\n\nwhile(temp->next!=NULL)\n\n{\n\ntemp=temp->next;\n\n}\n\nif(temp->next==NULL)\n\n{\n\nlast=(node *)malloc(sizeof(node));\n\nprintf("\\nEnter the element:- ");\n\nscanf("%d", &last->info);\n\ntemp->next=last;\n\nlast->next=NULL;\n\n}\n\nreturn(first);\n\n}`
            },
            {
                title: "SINGLE LINKLIST DELETION FROM ANY POSITION",
                filename: "pca.pdf (Program 10)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\ntypedef struct link\n\n{\n\nint info;\n\nstruct link *next;\n\n}node;\n\nvoid main()\n\n{\n\nnode *h;\n\nvoid create(node *);\n\nvoid show(node *);\n\nnode *del(node *);\n\nclrscr();\n\nh=(node *)malloc(sizeof(node));\n\ncreate(h);\n\nshow(h);\n\nh=del(h);\n\nshow(h);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nprintf("\\nEnter info");\n\nscanf("%d",&temp->info);\n\ntemp->next=NULL;\n\nprintf("\\nWant another?");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreate(temp->next);\n\n}\n\n}\n\nvoid show(node *temp)\n\n{\n\nwhile(temp!=NULL)\n\n{\n\nprintf("%4d",temp->info);\n\ntemp=temp->next;\n\n}\n\n}\n\nnode *del(node *temp)\n\n{\n\nint key;\n\nnode *p,*q,*f;\n\nf=temp;\n\nprintf("\\nEnter the node to delete:");\n\nscanf("%d", &key);\n\nwhile(temp->next!=NULL)\n\n{\n\nif(temp->info==key)\n\n{\n\nif(temp==f)\n\n{\n\np=temp->next;\n\nfree(temp);\n\nf=p;\n\n}\n\nelse\n\n{\n\np=temp->next;\n\nq->next =p;\n\nfree(temp);\n\n}\n\n}\n\n}\n\nq=temp;\n\ntemp=temp->next;\n\nif(temp->next==NULL && temp->info ==key)\n\n{\n\nq->next=NULL;\n\nfree(temp);\n\n}\n\nreturn(f);\n\n}`
            },
            {
                title: "PROGRAM OF SINGLE LINKED LIST INSERTION (ANY POSITION)",
                filename: "pca.pdf (Program 11)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\ntypedef struct link\n\n{\n\nint info;\n\nstruct link *next;\n\n}node;\n\nvoid main()\n\n{\n\nnode *head;\n\nvoid create(node *);\n\nnode * insert(node *);\n\nvoid show(node *);\n\nclrscr();\n\nhead=(node *)malloc(sizeof(node));\n\nprintf("\\n\\t CREATE LINKED LIST.\\n");\n\ncreate(head);\n\nprintf("\\n\\t DISPLAY LINKED LIST.\\n\\n");\n\nshow(head);\n\nprintf("\\n\\n\\tINSERTION.");\n\nhead=insert(head);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ans;\n\nprintf("\\nEnter the info::");\n\nscanf("%d",&temp->info);\n\ntemp->next=NULL;\n\nprintf("\\nWant another?");\n\nfflush(stdin);\n\nans=getchar();\n\nif(ans!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreate(temp->next);\n\n}\n\n}\n\nvoid show(node *temp)\n\n{\n\nif(temp->next==NULL)\n\nprintf("%4d",temp->info);\n\nelse\n\n{\n\nprintf("%4d",temp->info);\n\nshow(temp->next);\n\n}\n\n}\n\nnode *insert(node *temp)\n\n{\n\nnode *first,*list,*p;\n\nint pos,i;\n\nfirst=temp;\n\nprintf("\\nEnter the position::");\n\nscanf("%d",&pos);\n\nif(pos>1)\n\n{\n\nfor(i=1;i<pos-1;i++)\n\ntemp=temp->next;\n\n}\n\nlist=(node *)malloc(sizeof(node));\n\nprintf("\\nEnter the info::");\n\nscanf("%d",&list->info);\n\nif(temp->next==NULL)\n\n{\n\ntemp->next=list;\n\nlist->next=NULL;\n\n}\n\nelse if(temp==first && pos!=2)\n\n{\n\nlist->next=temp;\n\nfirst=list;\n\n}\n\nelse\n\n{\n\np=temp->next;\n\ntemp->next=list;\n\nlist->next=p;\n\n}\n\nreturn(first);\n\n}`
            },
            {
                title: "POLYNOMIAL ADDITION.",
                filename: "pca.pdf (Program 12)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\ntypedef struct poly\n\n{\n\nint coeff;\n\nint exp;\n\nstruct poly * next;\n\n}node;\n\nvoid main()\n\n{\n\nnode *head, *head1,*head2;\n\nvoid create(node *);\n\nvoid show(node *);\n\nnode *add(node *, node *);\n\nclrscr();\n\nprintf("\\n\\t\\t*****CREATE 1st POLYNOMIAL.*****\\n");\n\nhead1=(node *)malloc(sizeof(node));\n\ncreate(head1);\n\nclrscr();\n\nprintf("\\n\\t\\t*****CREATE 2nd POLYNOMIAL.*****\\n");\n\nhead2=(node *)malloc(sizeof(node));\n\ncreate(head2);\n\nclrscr();\n\nprintf("\\n\\t\\t*****SHOW 1st POLYNOMIAL.*****\\n");\n\nshow(head1);\n\nprintf("\\n\\t\\t*****SHOW 2nd POLYNOMIAL.*****\\n");\n\nshow(head2);\n\nprintf("\\n\\t\\t*****AFTER ADDITION.*****\\n");\n\nhead=add(head1, head2);\n\nshow(head);\n\ngetch();\n\n}\n\nvoid create(node *temp)\n\n{\n\nchar ch;\n\nprintf("\\nEnter the coefficient:- ");\n\nscanf("%d",&temp->coeff);\n\nprintf("\\nEnter the exponent:- ");\n\nscanf("%d",&temp->exp);\n\ntemp->next=NULL;\n\nprintf("\\nWant to continue(y/n):- ");\n\nfflush(stdin);\n\nch=getchar();\n\nif(ch!='y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreate(temp->next);\n\n}\n\n}\n\nvoid show(node *temp)\n\n{\n\nif(temp->next==NULL)\n\nprintf("%dX^%d =0\\\"\",temp->coeff,temp->exp);\n\nelse\n\n{\n\nprintf("%dX^%d + ",temp->coeff, temp->exp);\n\nshow(temp->next);\n\n}\n\n}\n\nnode *add(node *a, node *b)\n\n{\n\nnode *p,*q,*c,*d,*temp;\n\nint x;\n\nvoid attach(int,int, node *);\n\np=a;q=b;\n\nc=(node *)malloc(sizeof(node));\n\nd=c;\n\nwhile((p!=NULL)&&(q!=NULL))\n\n{\n\nif(p->exp==q->exp)\n\n{\n\nx=p->coeff+q->coeff;\n\nif(x!=0)\n\n{\n\nattach(x,p->exp,d);\n\np=p->next;\n\nq=q->next;\n\ntemp=d;\n\nd->next=(node *)malloc(sizeof(node));\n\nd=d->next;\n\n}\n\n}\n\nelse if(p->exp<q->exp)\n\n{\n\nattach(q->coeff,q->exp,d);\n\nq=q->next;\n\ntemp=d;\n\nd->next=(node *)malloc(sizeof(node));\n\nd=d->next;\n\n}\n\nelse\n\n{\n\nattach(p->coeff, p->exp,d);\n\np=p->next;\n\ntemp=d;\n\nd->next=(node *)malloc(sizeof(node));\n\nd=d->next;\n\n}\n\n}\n\nwhile(p!=NULL)\n\n{\n\nattach(p->coeff, p->exp,d);\n\np=p->next;\n\ntemp=d;\n\nd->next=(node *)malloc(sizeof(node));\n\nd=d->next;\n\n}\n\nwhile(q!=NULL)\n\n{\n\nattach(q->coeff,q->exp,d);\n\nq=q->next;\n\ntemp=d;\n\nd->next=(node *)malloc(sizeof(node));\n\nd=d->next;\n\n}\n\ntemp->next=NULL;\n\nd=c;\n\nreturn(d);\n\n}\n\nvoid attach(int c, int e, node *y)\n\n{\n\ny->coeff=c;\n\ny->exp=e;\n\n}`
            },
            {
                title: "SORT A LIST OF NUMBERS USING QUICK SORT",
                filename: "pca.pdf (Program 13 - Quick Sort)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\nvoid main()\n\n{\n\nint i, a[20],low=1,high;\n\nvoid qsort(int *,int,int);\n\nclrscr();\n\nprintf("\\nEnter how many number U want?");\n\nscanf("%d",&high);\n\nprintf("\\nEnter the numbers:: ");\n\nfor(i=low;i<=high;i++)\n\nscanf("%d",&a[i]);\n\nqsort(a, low,high);\n\nprintf("\\nSorted list::\\n");\n\nfor(i=low;i<=high;i++)\n\nprintf("%4d",a[i]);\n\ngetch();\n\n}\n\nvoid qsort(int *a, int p, int q)\n\n{\n\nint j;\n\nint partition(int *,int,int);\n\nif(p<q)\n\n{\n\nj=partition(a,p,q);\n\nqsort(a,p,j-1);\n\nqsort(a,j+1,q);\n\n}\n\n}\n\nint partition(int *a, int lb, int ub)\n\n{\n\nint m, beg, end, temp;\n\nm=a[lb];\n\nbeg=lb;end=ub;\n\nwhile(beg<end)\n\n{\n\nwhile(a[beg]<=m && beg<end)\n\nbeg++;\n\nwhile(a[end]>m)\n\nend--;\n\nif(beg<end)\n\n{\n\ntemp=a[beg];\n\na[beg]=a[end];\n\na[end]=temp;\n\n}\n\n}\n\na[lb]=a[end];\n\na[end]=m;\n\nreturn end;\n\n}`
            },
            {
                title: "SORT A LIST OF NUMBERS USING MERGE SORT",
                filename: "pca.pdf (Program 13 - Merge Sort)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\nvoid main()\n\n{\n\nint i, a[20],low=1,high;\n\nvoid mergesort(int *,int,int);\n\nclrscr();\n\nprintf("\\nEnter how many number U want?");\n\nscanf("%d",&high);\n\nprintf("\\nEnter the numbers:: ");\n\nfor(i=low;i<=high;i++)\n\nscanf("%d",&a[i]);\n\nmergesort(a,low, high);\n\nprintf("\\nSorted list::\\n");\n\nfor(i=low;i<=high;i++)\n\nprintf("%4d", a[i]);\n\ngetch();\n\n}\n\nvoid mergesort(int *a, int low, int high)\n\n{\n\nint mid;\n\nvoid merge(int *,int,int,int);\n\nif(low<high)\n\n{\n\nmid=(low+high)/2;\n\nmergesort(a, low, mid);\n\nmergesort(a,mid+1,high);\n\nmerge(a, low, mid, high);\n\n}\n\n}\n\nvoid merge(int *a, int low, int mid, int high)\n\n{\n\nint beg, end, i,k,b[30];\n\nbeg=i=low,end=mid+1;\n\nwhile((beg<=mid)&&(end<=high))\n\n{\n\nif(a[beg]<=a[end])\n\n{\n\nb[i]=a[beg];\n\nbeg++;\n\n}\n\nelse\n\n{\n\nb[i]=a[end];\n\nend++;\n\n}\n\ni++;\n\n}\n\nif(beg>mid)\n\n{\n\nfor(k=end;k<=high;k++)\n\n{\n\nb[i]=a[k];\n\ni++;\n\n}\n\n}\n\nelse\n\n{\n\nfor(k=beg;k<=mid;k++)\n\n{\n\nb[i]=a[k];\n\ni++;\n\n}\n\n}\n\nfor(k=low;k<=high;k++)\n\na[k]=b[k];\n\n}`
            },
            {
                title: "SORT A LIST OF NUMBERS USING INSERTION SORT",
                filename: "pca.pdf (Program 13 - Insertion Sort)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\nvoid main()\n\n{\n\nint i, high, a[30];\n\nclrscr();\n\nvoid insertion(int *,int);\n\nprintf("\\nEnter how many number U want? ");\n\nscanf("%d",&high);\n\nprintf("\\nEnter the numbers:: ");\n\nfor(i=1;i<=high;i++)\n\nscanf("%d",&a[i]);\n\ninsertion(a,high);\n\nprintf("\\n\\nDisplay sorted list::\\n");\n\nfor(i=1;i<=high;i++)\n\nprintf("%4d", a[i]);\n\ngetch();\n\n}\n\nvoid insertion(int *a, int high)\n\n{\n\nint temp, ptr,i;\n\na[0]=-20000;\n\nfor(i=2;i<=high;i++)\n\n{\n\ntemp=a[i];\n\nptr=i-1;\n\nwhile(temp<a[ptr])\n\n{\n\na[ptr+1]=a[ptr];\n\nptr=ptr-1;\n\n}\n\na[ptr+1]=temp;\n\n}\n\n}`
            },
            {
                title: "REVERSE A LINKED LIST",
                filename: "pca.pdf (Program 14)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\n#include<stdlib.h>\n\ntypedef struct data\n\n{\n\nint age;\n\nchar name [21];\n\nstruct data *next;\n\n}node;\n\nnode *head,*temp,*h1,*e1,*end;\n\nvoid creat(node *);\n\nvoid display(node *);\n\nnode *revlist(node *);\n\nvoid main()\n\n{\n\nclrscr();\n\nhead=(node *)malloc(sizeof(node));\n\ncreat(head); clrscr();\n\nprintf("\\n\\nEntered List Follows::\\n");\n\ndisplay(head);getch();\n\ntemp=(node *)malloc(sizeof(node));\n\ntemp=revlist(head);\n\nprintf("\\n\\nReversed List Follows::\\n");\n\ndisplay(temp);\n\ngetch();\n\n}\n\nvoid creat(node *temp)\n\n{\n\nchar ch;\n\nclrscr();\n\nprintf("\\n\\n\\t\\t\\tEnter Age = "); scanf("%d",&temp->age);\n\nprintf("\\n\\n\\t\\t\\tEnter Name:");\n\nfflush(stdin); gets(temp->name);\n\ntemp->next=NULL;\n\nprintf("\\n\\n\\n\\t\\tContinue? (y/n)");\n\nfflush(stdin); ch=getchar();\n\nif(ch!='y'&& ch!='Y')\n\nreturn;\n\nelse\n\n{\n\ntemp->next=(node *)malloc(sizeof(node));\n\ncreat(temp->next);\n\n}\n\n}\n\nvoid display(node *temp)\n\n{\n\nprintf("\\n\\n\\t\\t\\t%d\\t%s",temp->age,temp->name);\n\nif(temp->next!=NULL)\n\ndisplay(temp->next);\n\nreturn;\n\n}\n\nnode *revlist(node *h1)\n\n{\n\nend=NULL;\n\nwhile(h1!=NULL)\n\n{\n\ne1=h1->next;\n\nh1->next=end;\n\nend=h1;\n\nh1=e1;\n\n}\n\n}\n\nreturn(end);`
            },
            {
                title: "PROGRAM OF TOWER OF HANOI USING RECURSION.",
                filename: "pca.pdf (Program 15)",
                code: `#include<stdio.h>\n\n#include<conio.h>\n\nvoid main()\n\n{\n\nint no;\n\nchar left ='L',mid ='M', right ='R';\n\nvoid t_hanoi(int, char, char,char);\n\nclrscr();\n\nprintf("\\nEnter the number of disks:- ");\n\nscanf("%d",&no);\n\nt_hanoi(no, left, mid, right);\n\nprintf("\\n\\n");\n\ngetch();\n\n}\n\nvoid t_hanoi(int n, char l,char m, char r)\n\n{\n\nif(n!=0)\n\n{\n\nt_hanoi(n-1,l,r,m);\n\nprintf("\\nMove disk %d from %c to %c", n,l,r);\n\nt_hanoi(n-1,m,l,r);\n\n}\n\n}`
            }
        ];

        // --- Main Application Logic (Simplified) ---
        function initializeApp() {
            const codeListView = document.getElementById('code-list-view');
            const codeDetailView = document.getElementById('code-detail-view');
            const backButton = document.getElementById('back-button');

            // Function to switch views
            function showListView() {
                codeListView.classList.remove('hidden');
                codeDetailView.classList.add('hidden');
            }

            function showDetailView(codeData) {
                document.getElementById('detail-title').textContent = codeData.title;
                document.getElementById('detail-filename').textContent = `Source: ${codeData.filename}`;
                document.getElementById('detail-code').textContent = codeData.code;
                
                // Update copy button functionality for the current code
                const detailCopyButton = document.getElementById('detail-copy-button');
                detailCopyButton.onclick = () => {
                    const textarea = document.createElement('textarea');
                    textarea.value = codeData.code;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        // Use the deprecated but widely supported execCommand for clipboard access in limited contexts
                        const success = document.execCommand('copy'); 
                        detailCopyButton.textContent = success ? 'Copied!' : 'Copy Failed!';
                    } catch (err) {
                        detailCopyButton.textContent = 'Copy Failed!';
                        console.error('Could not copy text: ', err);
                    }
                    document.body.removeChild(textarea);
                    setTimeout(() => detailCopyButton.textContent = 'Copy Code', 2000);
                };

                codeListView.classList.add('hidden');
                codeDetailView.classList.remove('hidden');
                window.scrollTo(0, 0); // Scroll to the top when switching to detail view
            }
            
            // Setup Back Button Handler
            backButton.addEventListener('click', showListView);

            // Function to create a clickable card for the list view
            function createListCard(codeData) {
                const card = document.createElement('div');
                // Updated class names for neon style
                card.className = 'card p-5 cursor-pointer border-l-4 border-neon-cyan hover:shadow-2xl list-card-glow transition-all duration-200';
                
                const title = document.createElement('h2');
                title.className = 'text-lg font-semibold text-text-light truncate';
                title.textContent = codeData.title;
                
                const filename = document.createElement('p');
                filename.className = 'text-sm text-gray-400 mt-1';
                filename.textContent = codeData.filename;

                card.appendChild(title);
                card.appendChild(filename);

                // Click handler to switch to detail view
                card.addEventListener('click', () => showDetailView(codeData));

                return card;
            }

            // Render all list cards
            codes.forEach(codeData => {
                const card = createListCard(codeData);
                codeListView.appendChild(card);
            });
        }

        // Start the application when the DOM is ready (the simplest, most reliable way)
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
