<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Algorithm Code Vault (Static)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Code:wght@400&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f9;
        }
        .code-container {
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap; /* Allows text to wrap */
            word-wrap: break-word; /* Ensures long words break */
            max-height: 70vh;
            overflow-y: auto;
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 1rem;
            border-radius: 0.5rem;
            line-height: 1.4;
            font-size: 0.9rem;
        }
        .code-container::-webkit-scrollbar {
            width: 8px;
        }
        .code-container::-webkit-scrollbar-thumb {
            background-color: #6366f1;
            border-radius: 4px;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div id="app" class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10">
        <h1 class="text-3xl md:text-4xl font-extrabold text-indigo-700 mb-2">C Algorithm Vault (Static)</h1>
        <p class="text-gray-600 mb-6 border-b pb-4">All code is stored locally within this single HTML file. Ready for GitHub Pages.</p>

        <!-- Loading/Status Indicator - Simplified for static content -->
        <div id="status-message" class="flex items-center justify-center p-4 bg-yellow-100 text-yellow-800 rounded-lg hidden">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-yellow-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span id="status-text">Loading application...</span>
        </div>

        <!-- Main Content Area -->
        <div id="content-area">
            <!-- Snippet List View -->
            <div id="snippet-list-view">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Available Algorithms</h2>
                <div id="snippets-container" class="space-y-3">
                    <!-- Snippets will be injected here -->
                </div>
            </div>

            <!-- Snippet Detail View -->
            <div id="snippet-detail-view" class="hidden">
                <button onclick="goBack()" class="flex items-center text-indigo-600 hover:text-indigo-800 mb-4 font-medium transition duration-150">
                    <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    Back to List
                </button>
                <h2 id="detail-title" class="text-2xl font-bold text-gray-800 mb-4"></h2>
                
                <div class="flex justify-end mb-2">
                    <button id="copy-button" onclick="copyCode()" class="px-4 py-2 bg-green-500 text-white text-sm font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-200 flex items-center">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2m-6 0h6m-6 0h-2"></path></svg>
                        Copy Code
                    </button>
                </div>

                <div id="detail-code" class="code-container">
                    <!-- Code content goes here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        
        // --- Global Application Variables ---
        let snippets = [];
        let currentSnippet = null;

        // --- DOM Elements ---
        const statusMessageEl = document.getElementById('status-message');
        const statusTextEl = document.getElementById('status-text');
        const snippetsContainerEl = document.getElementById('snippets-container');
        const listEl = document.getElementById('snippet-list-view');
        const detailEl = document.getElementById('snippet-detail-view');
        const detailTitleEl = document.getElementById('detail-title');
        const detailCodeEl = document.getElementById('detail-code');
        const copyButton = document.getElementById('copy-button');

        // Initial Data now stored locally in the JS scope
        const initialSnippets = [
            { id: 1, title: "1. INSERTION SORT (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n\nvoid main()\n{\n    int n, i, j, key;\n    int arr[100]; /* fixed size array (Turbo C doesn't allow int arr[n]) */\n\n    clrscr(); /* clear screen */\n    printf("Enter number of elements: ");\n    scanf("%d", &n);\n\n    printf("Enter %d elements: ", n);\n    for (i = 0; i < n; i++)\n    {\n        scanf("%d", &arr[i]);\n    }\n\n    /* Insertion Sort */\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n\n    /* Print sorted array */\n    printf("\\nSorted array: ");\n    for (i = 0; i < n; i++)\n    {\n        printf("%d", arr[i]);\n    }\n\n    getch(); /* wait for key press before closing */\n}` },
            { id: 2, title: "2. QUICK SORT (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n\nvoid swap(int *a, int *b)\n{\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[high];\n    int i = low - 1;\n    int j;\n\n    for (j = low; j < high; j++)\n    {\n        if (arr[j] < pivot)\n        {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high)\n{\n    int pi;\n    if (low < high)\n    {\n        pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid main()\n{\n    int arr[50];\n    int n, i;\n\n    clrscr(); // Clears the Turbo C screen\n    printf("Enter number of elements: ");\n    scanf("%d", &n);\n\n    printf("Enter %d elements: \\n", n);\n    for (i = 0; i < n; i++)\n        scanf("%d", &arr[i]);\n\n    quickSort(arr, 0, n - 1);\n\n    printf("\\nSorted array: ");\n    for (i = 0; i < n; i++)\n        printf("%d", arr[i]);\n\n    getch(); // Waits for key press before closing output screen\n}` },
            { id: 3, title: "3. ITERATIVE BINARY SEARCH (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n\nint binarySearch(int arr[], int n, int key) {\n    int low = 0, high = n - 1, mid;\n\n    while (low <= high) {\n        mid = (low + high) / 2;\n\n        if (arr[mid] == key)\n            return mid; // Element found\n        else if (arr[mid] < key)\n            low = mid + 1; // Search right half\n        else\n            high = mid - 1; // Search left half\n    }\n\n    return -1; // Element not found\n}\n\nint main() {\n    int n, key, i, result;\n    int arr[100]; // fixed-size array for Turbo C\n\n    clrscr();\n\n    printf("Enter number of elements: ");\n    scanf("%d", &n);\n\n    printf("Enter %d sorted elements: ", n);\n    for (i = 0; i < n; i++)\n        scanf("%d", &arr[i]);\n\n    printf("Enter element to search: ");\n    scanf("%d", &key);\n\n    result = binarySearch(arr, n, key);\n\n    if (result == -1)\n        printf("Element not found.\\n");\n    else\n        printf("Element found at position %d.\\n", result + 1);\n\n    getch();\n    return 0;\n}` },
            { id: 4, title: "4. RECURSIVE BINARY SEARCH (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n\nint binarySearch(int arr[], int low, int high, int key) {\n    int mid;\n\n    if (low > high)\n        return -1; // Base case: not found\n\n    mid = (low + high) / 2;\n\n    if (arr[mid] == key)\n        return mid; // Element found\n    else if (arr[mid] > key)\n        return binarySearch(arr, low, mid - 1, key); // Left half\n    else\n        return binarySearch(arr, mid + 1, high, key); // Right half\n}\n\nint main() {\n    int n, key, i, result;\n    int arr[100]; // Fixed-size array for Turbo C\n\n    clrscr();\n\n    printf("Enter number of elements: ");\n    scanf("%d", &n);\n\n    printf("Enter %d sorted elements: ", n);\n    for (i = 0; i < n; i++)\n        scanf("%d", &arr[i]);\n\n    printf("Enter element to search: ");\n    scanf("%d", &key);\n\n    result = binarySearch(arr, 0, n - 1, key);\n\n    if (result == -1)\n        printf("Element not found.\\n");
    else\n        printf("Element found at position %d\\n", result + 1);\n\n    getch();\n    return 0;\n}` },
            { id: 5, title: "5. REVERSE SINGLE LIST (Static Data) (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n#include <stdlib.h>\n\n// Define the node structure\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to reverse the linked list\nstruct Node* reverseList(struct Node* head) {\n    struct Node* prev = NULL;\n    struct Node* current = head;\n    struct Node* next = NULL;\n\n    while (current != NULL) {\n        next = current->next;     // Store next node\n        current->next = prev;     // Reverse current node's pointer\n        prev = current;           // Move prev one step forward\n        current = next;           // Move current one step forward\n    }\n\n    return prev; // New head of the reversed list\n}\n\n// Function to print the linked list\nvoid printList(struct Node* head) {\n    struct Node* temp = head;\n\n    while (temp != NULL) {\n        printf("%d -> ", temp->data);\n        temp = temp->next;\n    }\n    printf("NULL\\n");\n}\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (newNode == NULL) {\n        printf("Memory not allocated.\\n");\n        getch();\n        exit(0);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    clrscr(); // Clear screen in Turbo C\n\n    // Creating a sample linked list: 1 -> 2 -> 3 -> 4 -> NULL\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n\n    printf("Original List:\\n");\n    printList(head);\n\n    head = reverseList(head);\n\n    printf("Reversed List:\\n");\n    printList(head);\n\n    getch(); // Wait for key press\n    return 0;\n}` },
            { id: 6, title: "6. REVERSE SINGLE LIST (User Input) (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n#include <stdlib.h>\n\n// Define the node structure\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to reverse the linked list\nstruct Node* reverseList(struct Node* head) {\n    struct Node* prev = NULL;\n    struct Node* current = head;\n    struct Node* next = NULL;\n\n    while (current != NULL) {\n        next = current->next;     // Store next node\n        current->next = prev;     // Reverse current node's pointer\n        prev = current;           // Move prev one step forward\n        current = next;           // Move current one step forward\n    }\n\n    return prev; // New head of the reversed list\n}\n\n// Function to print the linked list\nvoid printList(struct Node* head) {\n    struct Node* temp = head;\n\n    while (temp != NULL) {\n        printf("%d -> ", temp->data);\n        temp = temp->next;\n    }\n    printf("NULL\\n");\n}\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    if (!newNode) {\n        printf("Memory allocation failed\\n");\n        getch();\n        exit(1);\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    clrscr(); // Clear screen in Turbo C\n\n    int n, i, value;\n    struct Node* head = NULL;\n    struct Node* tail = NULL;\n\n    printf("Enter the number of nodes: ");\n    scanf("%d", &n);\n\n    for (i = 0; i < n; i++)\n    {\n        printf("Enter value for node %d: ", i + 1);\n        scanf("%d", &value);\n\n        struct Node* newNode = createNode (value);\n\n        if (head == NULL) {\n            head = newNode; // First node\n            tail = newNode;\n        } else {\n            tail->next = newNode; // Append to the list\n            tail = newNode;\n        }\n    }\n\n    printf("\\nOriginal List:\\n");\n    printList(head);\n\n    head = reverseList(head);\n\n    printf("\\nReversed List:\\n");\n    printList(head);\n\n    // Free memory\n    struct Node* temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n\n    getch(); // Wait for key press\n    return 0;\n}` },
            { id: 7, title: "7. MERGING OF TWO SORTED LISTS (Static Data) (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* n;\n    n = (struct Node*)malloc(sizeof(struct Node));\n    n->data = data;\n    n->next = NULL;\n    return n;\n}\n\nstruct Node* merge (struct Node* a, struct Node* b) {\n    if (a == NULL) return b;\n    if (b == NULL) return a;\n\n    struct Node* head;\n    if (a->data < b->data) {\n        head = a;\n        a = a->next;\n    } else {\n        head = b;\n        b = b->next;\n    }\n\n    struct Node* tail = head;\n\n    while (a != NULL && b != NULL) {\n        if (a->data < b->data) {\n            tail->next = a;\n            tail = a;\n            a = a->next;\n        } else {\n            tail->next = b;\n            tail = b;\n            b = b->next;\n        }\n    }\n\n    if (a != NULL) tail->next = a;\n    else tail->next = b;\n\n    return head;\n}\n\nint printList(struct Node* head) {\n    int count = 0;\n    while (head != NULL) {\n        printf("%d -> ", head->data);\n        head = head->next;\n        count++;\n    }\n    printf("NULL\\n");\n    return count;\n}\n\nint main()\n{\n    clrscr();\n\n    struct Node* l1 = createNode(1);\n    l1->next = createNode(3);\n    l1->next->next = createNode(5);\n\n    struct Node* l2 = createNode(2);\n    l2->next = createNode(4);\n    l2->next->next = createNode(6);\n\n    struct Node* merged = merge(l1, l2);\n\n    printf("Merged List: ");\n    int total = printList(merged);\n    printf("Total nodes: %d\\n", total);\n\n    getch(); // pause for Turbo C\n    return 0;\n}` },
            { id: 8, title: "8. MERGING OF TWO SORTED LISTS (User Input) (C)", language: "c", code: `#include <stdio.h>\n#include <conio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int data) {\n    struct Node* n;\n    n = (struct Node*)malloc(sizeof(struct Node));\n    n->data = data;\n    n->next = NULL;\n    return n;\n}\n\nstruct Node* merge(struct Node* a, struct Node* b) {\n    if (a == NULL) return b;\n    if (b == NULL) return a;\n\n    struct Node* head;\n\n    if (a->data < b->data) {\n        head = a;\n        a = a->next;\n    } else {\n        head = b;\n        b = b->next;\n    }\n\n    struct Node* tail = head;\n\n    while (a != NULL && b != NULL) {\n        if (a->data < b->data) {\n            tail->next = a;\n            tail = a;\n            a = a->next;\n        } else {\n            tail->next = b;\n            tail = b;\n            b = b->next;\n        }\n    }\n\n    if (a != NULL) tail->next = a;\n    else tail->next = b;\n\n    return head;\n}\n\nint printList(struct Node* head) {\n    int count = 0;\n    while (head != NULL) {\n        printf("%d -> ", head->data);\n        head = head->next;\n        count++;\n    }\n    printf("NULL\\n");\n    return count;\n}\n\nstruct Node* inputList(int n) {\n    int i, val;\n    struct Node *head = NULL, *tail = NULL;\n    printf("Enter %d elements in ascending order, separated by spaces/newlines: ", n);\n    for (i = 0; i < n; i++) {\n        scanf("%d", &val);\n        struct Node* node = createNode (val);\n        if (head == NULL) head = tail = node;\n        else { tail->next = node; tail = node; }\n    }\n    return head;\n}\n\nint main() {\n    clrscr();\n\n    int n1, n2;\n    struct Node *l1, *l2, *merged;\n    int total;\n\n    printf("Enter number of elements in first sorted list: ");\n    scanf("%d", &n1);\n\n    l1 = inputList(n1);\n\n    printf("Enter number of elements in second sorted list: ");\n    scanf("%d", &n2);\n\n    l2 = inputList(n2);\n\n    merged = merge (l1, l2);\n\n    printf("Merged List: ");\n    total = printList(merged);\n    printf("Total nodes: %d\\n", total);\n\n    getch(); // pause output for Turbo C\n    return 0;\n}` },
        ];


        // --- Utility Functions ---

        function updateStatus(message, isError = false) {
            statusTextEl.textContent = message;
            statusMessageEl.classList.remove('hidden', 'bg-yellow-100', 'bg-red-100', 'text-yellow-800', 'text-red-800');
            statusMessageEl.classList.add(isError ? 'bg-red-100' : 'bg-yellow-100', isError ? 'text-red-800' : 'text-yellow-800');
        }

        function hideStatus() {
            statusMessageEl.classList.add('hidden');
        }

        // --- Core Application Logic ---

        /**
         * Initializes and renders the snippet data directly from the local array.
         */
        function initializeStaticData() {
            updateStatus('Loading static code snippets...');
            
            // Set global snippets array and sort it
            snippets = initialSnippets;
            snippets.sort((a, b) => a.id - b.id);
            
            renderSnippetList();
            
            updateStatus('Code vault loaded successfully.', false);
            setTimeout(hideStatus, 1500);
        }


        // --- UI Rendering and Interaction ---

        function renderSnippetList() {
            snippetsContainerEl.innerHTML = '';
            if (snippets.length === 0) {
                snippetsContainerEl.innerHTML = '<p class="text-gray-500">No code snippets found.</p>';
                return;
            }

            snippets.forEach(snippet => {
                const div = document.createElement('div');
                div.className = 'p-4 bg-indigo-50 hover:bg-indigo-100 rounded-lg shadow-sm cursor-pointer transition duration-150 flex justify-between items-center';
                div.innerHTML = `
                    <span class="font-medium text-lg text-indigo-800">${snippet.title}</span>
                    <span class="text-sm font-code text-gray-500 bg-indigo-200 px-2 py-1 rounded-full">C</span>
                `;
                div.onclick = () => showDetail(snippet.id);
                snippetsContainerEl.appendChild(div);
            });
        }

        window.showDetail = function(id) {
            currentSnippet = snippets.find(s => s.id === id);
            if (currentSnippet) {
                listEl.classList.add('hidden');
                detailEl.classList.remove('hidden');
                renderDetailView();
            }
        }
        
        function renderDetailView() {
            if (!currentSnippet) return;
            detailTitleEl.textContent = currentSnippet.title;
            detailCodeEl.textContent = currentSnippet.code;
        }

        window.goBack = function() {
            currentSnippet = null;
            listEl.classList.remove('hidden');
            detailEl.classList.add('hidden');
        }

        window.copyCode = function() {
            if (!currentSnippet) return;
            
            // Use document.execCommand('copy') for better compatibility in iframe environments
            const textarea = document.createElement('textarea');
            textarea.value = currentSnippet.code;
            textarea.style.position = 'fixed'; // Prevents scrolling to bottom
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                const message = successful ? 'Copied!' : 'Copy failed.';
                
                // Show temporary feedback on the button
                copyButton.textContent = message;
                copyButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                copyButton.classList.add('bg-indigo-500', 'hover:bg-indigo-600');

                setTimeout(() => {
                    copyButton.innerHTML = `<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2m-6 0h6m-6 0h-2"></path></svg>Copy Code`;
                    copyButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    copyButton.classList.remove('bg-indigo-500', 'hover:bg-indigo-600');
                }, 1500);

            } catch (err) {
                console.error('Copy command failed:', err);
            } finally {
                document.body.removeChild(textarea);
            }
        }

        // Start the application setup when the window loads
        window.onload = initializeStaticData;
    </script>
</body>
</html>
